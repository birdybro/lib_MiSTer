* $Id$
******************************************************
*
* TraceBug Monitor ROM for the 6809
*
* For the Digilent Spartan3E Starter Board
* And System09_Digilent_3S500E
* Should also run on a Reference 6809 Board
*
* Revision: 1.1
* Date:     24 May 2006 
* Author:   John Kent
*
* Revision History:
* 23 April 2006
* Configured for the Spartan3E Starter Board
* Added Trace command using PIA Timer Hardware
*
* 24 May 2006
* Changed trace timer value from 12 ($0C)
* to 13 ($0D) for the Reference 6809 board.
* The Spartan 3E board must be updated to
* compensate for the extra cycle delay.
*
******************************************************
*
*
** MONITOR MEMORY MAP
*
RAM     EQU    $7FC0     START OF MONITOR RAM
ROM     EQU    $E000     START OF MONITOR ROM
EXTIO   EQU    $8000     OFF BOARD IO BASE
INTIO   EQU    $8000     ON BOARD DEVICES
ROMSIZE EQU    8192      MAKE THE ROM 8K
*
* OPTION SWITCHES
*
*DG640OPT EQU $FF VIDEO
*PRTOPT   EQU $FF PRINTER
*CLKOPT   EQU $FF REAL TIME CLOCK
*FDCOPT   EQU $FF FLOPPY DISK
*ADM3AOPT EQU $FF FPGA VIDEO
*KBDOPT   EQU $FF PS/2 Keyboard interface
SEROPT    EQU $FF ACIA SERIAL Option
TRAOPT    EQU $FF PIA Timer Trace Option
*
******************************************************
*
* IO EQUATES:
*
******************************************************
 IFD SEROPT
*
** ACIA - TTY INTERFACE
*
ACIAS  EQU INTIO+$08
*ACIAS  EQU EXTIO+$00
 ENDIF SEROPT
 IFD TRAOPT
*
** PIA TIMER FOR SINGLE STEP
*
* TADATA = Output = Timer preset register
* TACTRL - CA1 = input = rising edge = NMI
*        - CA2 = Output = Timer Reset (Active High)
* TBDATA = Input = Timer read back register
* TBCTRL - CB1 = input = rising edge = FIRQ
*        - CB2 = output = strobe low on write to TBDATA = Timer Preset
*
* CRA0 = 0 CA1 IRQ DISAB, CRA0 = 1 CA1 IRQ ENAB
* CRA1 = 1 CA1 Rising edge IRQ
* CRA2 = 0 TADATA = Data Direction, CRA2 = 1 TADATA = I/O Register
* CRA3 = 0 CA2 = 0 output, CRA3 = 1 CA2 = 1
* CRA4 = 1 ] CA2 = Set/Reset output
* CRA5 = 1 ]
* CRA6 = X CA2 Input Interrupt Flag
* CRA7 = X CA1 Interrupt Flag
*
* CRB0 = 0 CB1 IRQ DISAB, CRB0 = 1 CA1 IRQ ENAB
* CRB1 = 1 CB1 Rising edge IRQ
* CRB2 = 0 TBDATA = Data Direction, CRB2 = 1 TBDATA = I/O Register
* CRB3 = 0 CB2 = 0 output, CRB3 = 1 CB2 = 1
* CRB4 = 1 ] CB2 = Set/Reset output
* CRB5 = 1 ]
* CRB6 = X CB2 Input Interrupt Flag
* CRB7 = X CB1 Interrupt Flag
*
* DDRA = 0 TADATA = Input, DDRA = 1 TADATA = Output
* DDRB = 0 TBDATA = Input, DDRB = 1 TBDATA = Output
*
TADATA EQU INTIO+$04 Timer preset port
TACTRL EQU INTIO+$05
TBDATA EQU INTIO+$06 Timer read back port
TBCTRL EQU INTIO+$07
*
TRADEL EQU 13  Number of E cycles for RTI (May need to be fudged)
*
 ENDIF TRAOPT
 IFD PRTOPT
*
** PRINTER INTERFACE
*
PADATA EQU INTIO+$04
PACTRL EQU INTIO+$05
PBDATA EQU INTIO+$06
PBCTRL EQU INTIO+$07
*
** CB1  ACK.  I/P
** CB2  STB.  O/P
** PB0 - PB7   DATA 1 - 8   O/P
** PORT A BIT ASSIGNMENT
*
PBUSY  EQU $80 I/P
PEMPTY EQU $40 I/P
SELECT EQU $20 I/P
PERROR EQU $10 I/P
PRESET EQU %00000100 O/P PA3 = 0
AUTOFD EQU %00001000 O/P PA2 = 0
DIRMSK EQU %00001100
 ENDIF PRTOPT
 IFD FDCOPT
*
** FLOPPY DISK CONTROLLER
*
DRVREG EQU EXTIO+$14
CMDREG EQU EXTIO+$18
SECREG EQU EXTIO+$1A
DATREG EQU EXTIO+$1B
 ENDIF FDCOPT
*
 IFD CLKOPT
*
*
* MM58167A REAL TIME CLOCK MEMORY MAP:
*
CLOCK  EQU $E040 CLOCK BASE ADDRESS AND REGISTERS
*
* CLOCK REGISTER OFFSETS:
* These register offsets are used for the CLOCK
* and comparitor ram CMPRAM.
*
S10000 EQU 0 TEN THOUNSANDTHS OF SECONDS
S100   EQU 1 HUNDRETHS AND TENTHS OF SECONDS
SECOND EQU 2
MINUIT EQU 3
HOUR   EQU 4
WKDAY  EQU 5
MTHDAY EQU 6
MONTH  EQU 7
*
* COUNTER AND COMPARITOR REGISTERS:
*
* Both the Clock Counter and Clock Comparitor
* consist of 8 registers for holding the time.
* The register offsets from the Counter and
* Comparitor registers are listed above.
*
COUNTR EQU CLOCK+0
CMPRAM EQU CLOCK+8 COMPARITOR REGISTERS
*
* INTERRUPT OUTPUT REGISTERS:
*
* An interrupt output may be generated at the
* following rates by setting the appropriate bit
* in the Interrupt Control Register (CINTCR).
* The Interrupt Status Register (CINTSR) must be
* read to clear the interrupt and will return
* the source of the interrupt.
*
* 1/Month      Bit 7
* 1/Week       Bit 6
* 1/Day        Bit 5
* 1/Hour       Bit 4
* 1/Minuite    Bit 3
* 1/Second     Bit 2
* 10/Second    Bit 1
* Comparitor   Bit 0
*
CINTSR  EQU CLOCK+16 INTERRUPT STATUS REGISTER
CINTCR  EQU CLOCK+17 INTERRUPT CONTROL REGISTER
*
* COUNTER AND RAM RESETS; GO COMMAND.
*
* The counter and comparitor may be reset
* by writing $FF into CTRRES and CMPRES
* respectivly.
* A write to the Go command register (GOCMND)
* will reset the 1/1000ths, 1/100ths and 1/10ths
* of a second counter.
*
CTRRES EQU CLOCK+18 COUNTER RESET
CMPRES EQU CLOCK+19 COMPARITOR RAM RESET
GOCMND EQU CLOCK+21 GO COMMAND
*
* CLOCK STATUS REGISTER.
*
* The counter takes 61 usec. to rollover for
* every 1KHz clock pulse. If the Status bit is
* set after reading the counter, the counter
* should be re-read to ensure the time is correct.
*
CLKSTA EQU CLOCK+20 STATUS BIT
SBYINT EQU CLOCK+22 STANDBY INTERRUPT
TSTMOD EQU CLOCK+31 TEST MODE REGISTER
 ENDIF CLKOPT
*
 IFD KBDOPT
*****************************************************
*
* PS/2 Keyboard Interface
*
*****************************************************
KBPORT  EQU EXTIO+$20
 ENDIF KBDOPT
*****************************************************
*
* RAM ALLOCATION:
*
*****************************************************
*
** ALTERABLE INTERRUPT VECTOR TABLE
*
 ORG RAM
STACK RMB 2
SWI3 RMB 2 SWI3 Jump Vector
SWI2 RMB 2 SWI2 Jump Vector
FIRQ RMB 2 FIRQ Jump Vector
IRQ RMB 2 IRQ Jump Vector
SWI RMB 2 SWI Jump Vector
NMI RMB 2 NMI Jump Vector
SVCVO RMB 2
SVCVL RMB 2 
 IFD TRAOPT
NMISAV RMB 2 NMI Jump Vector Backup
TRACNT RMB 2 Trace Count
  ENDIF TRAOPT
*
** I/O CONTROL PARAMETERS
*
CPORT RMB 2 REVECTORABLE CONTROL PORT
ECHO RMB 1 ECHO FLAG
 IFD DG640OPT
***************************************************
*   DG640 MEMORY MAPPED DISPLAY DRIVER VARIABLES  *
***************************************************
*
** VIDEO DISPLAY DEFINITIONS
*
SCREEN  EQU    $E800     START OF SCREEN MEMORY
LINLEN  EQU    64       LENGTH OF A LINE
NUMLIN  EQU    16       NUMBER OF LINES
SCNLEN  EQU    $400      LENGTH OF SCREEN
*
***** ALWAYS KEEP THESE TWO BYTES TOGETHER *****
COLADX  RMB    1         CURSOR COLUMN
ROWADX  RMB    1         CURSOR ROW
*************************************************
CURSOR  RMB    2         ABSOLUTE SCREEN ADDRESS
NEWROW  RMB    1         NEW ROW TEMP FOR ESCAPE
ESCFLG  RMB    1         ESCAPE SEQUENCE ACTIVE
 ENDIF DG640OPT
 IFD ADM3AOPT
***************************************************
*   ADM3A DISPLAY DRIVER VARIABLES                *
***************************************************
*
** VIDEO DISPLAY DEFINITIONS
*
VDU     EQU    EXTIO+$30
VDUCHR  EQU    0        CHARACTER REGISTER
VDUATT  EQU    1        ATTRIBUTE REGISTER
VDUCOL  EQU    2        CURSOR COLUMN
VDUROW  EQU    3        CURSOR ROW
VDUOFF  EQU    4        ROW OFFSET
*
LINLEN  EQU    80       LENGTH OF A LINE
NUMLIN  EQU    25       NUMBER OF LINES
*
***** ALWAYS KEEP THESE TWO BYTES TOGETHER *****
COLADX  RMB    1         CURSOR COLUMN
ROWADX  RMB    1         CURSOR ROW
*************************************************
NEWROW  RMB    1         NEW ROW TEMP FOR ESCAPE
ESCFLG  RMB    1         ESCAPE SEQUENCE ACTIVE
 ENDIF ADM3AOPT
*
* ACIA/VDU OUTPUT SWITCH
*
OUTFLG RMB     1        ACIA/VDU OUTPUT SWITCH
INFLG  RMB     1        KEYBOARD/ACIA INPUT SWITCH
VDUBIT EQU $01 VIDEO OUTPUT
KBDBIT EQU $01 KEYBOARD INPUT
SERBIT EQU $02 SERIAL INPUT/OUTPUT
PRTBIT EQU $04 PRINTER OUTPUT
*
BPTBL RMB 24 BREAK POINT TABLE BASE ADDRESS
*
** MONITOR ROUTINE JUMP VECTORS
*
 ORG ROM
 FDB MONITOR
 FDB NEXTCMD
 FDB INCH
 FDB INCHE
 FDB INCHEK
 FDB OUTCH
 FDB PDATA
 FDB PCRLF
 FDB PSTRNG
 FDB LRA
*
 IFD PRTOPT
 FDB PINIZ INITIATE PRINTER
 FDB PCHK  CHECK FOR PRINTER READY
 FDB DUMRTS NO INPUT ROUTINE
 FDB POUTCH OUTPUT CH. TO PRINTER
 ELSE
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 ENDIF PRTOPT
*
 IFD DG640OPT
 FDB VINIZ
 FDB ACINCHK
 FDB ACINCH
 FDB VOUTCH
 ELSE
 IFD ADM3AOPT
 FDB VINIZ
 FDB KBINCHK
 FDB KBINCH
 FDB VOUTCH
 ELSE
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 ENDIF ADM3AOPT
 ENDIF DG640OPT
*
 IFD SEROPT
 FDB ACINIZ
 FDB ACINCHK
 FDB ACINCH
 FDB ACOUTCH
 ELSE
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 ENDIF SEROPT
*
 IFD KBDOPT
 FDB KBINIZ
 FDB KBINCHK
 FDB KBINCH
 FDB KBOUTCH
 ELSE
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 FDB DUMRTS
 ENDIF KBDOPT
*
** POWER ON RESET
*
START LDS #STACK
*
** MONITOR ENTRY POINT
*
** MOVE ROM INTERRUPT JUMP VECTORS TO RAM
*
MONITOR LDX #RAMVEC
 LDY #STACK
 LDB #$12
LOOPA LDA ,X+
 STA ,Y+
 DECB 
 BNE LOOPA
*
** SET UP CONTROL PORT POINTER
** (USUALLY AN ACIA)
*
 LDX #ACIAS
 STX CPORT
 LBSR XBKPNT
*
** CLEAR 12 ENTRIES ON STACK
*
 LDB #$0C
CLRSTK CLR ,-S
 DECB 
 BNE CLRSTK
 LEAX MONITOR,PCR PRESET PC TO MONITOR
 STX $0A,S
 LDA #$D0 PRESET C.C.
 STA ,S
 TFR S,U
*
** INITIATE VDU AND ACIA
*
 LDA #SERBIT+VDUBIT START UP ON ACIA AND VDU
 STA OUTFLG
 LDA #SERBIT+KBDBIT START UP ON ACIA AND KEYBOARD
 STA INFLG
*
 IFD SEROPT
 LBSR ACINIZ
 ENDIF SEROPT
*
 IFD KBDOPT
 LBSR KBINIZ
 ENDIF KBDOPT
*
 IFD DG640OPT
 LBSR VINIZ
 ENDIF DG640OPT
*
 IFD ADM3AOPT
 LBSR VINIZ
 ENDIF ADM3AOPT
*
 IFD CLKOPT
 LBSR CLKINZ
 ENDIF CLKOPT
*
 IFD TRAOPT
 LBSR TRAINZ
 ENDIF TRAOPT
*
 LDX #TTLMSG
 LBSR PDATA
*
** GET COMMAND FROM OPERATOR
*
NEXTCMD LDX #PMTMSG
 LBSR PSTRNG
 LBSR INCH
 ANDA #$7F
 CMPA #$0D
 BEQ NEXTCMD
 TFR A,B
 CMPA #$20
 BGE PRTCMD
 LDA #$5E
 LBSR OUTCH
 TFR B,A
 ADDA #$40
PRTCMD LBSR OUTCH
 LBSR OUT1S
*
** DO COMMAND TABLE LOOKUP
*
 LDX #JMPTAB
NXTCHR CMPB ,X+
 BEQ JMPCMD
 LEAX $02,X
 CMPX #JMPEND
 BNE NXTCHR
 LDX #QRYMSG
 LBSR PDATA
 BRA NEXTCMD
JMPCMD JSR [,X]
 BRA NEXTCMD
*
** "M" MEMORY EXAMINE AND CHANGE
*
MEMCHG LBSR IN1ADR
 BVS CHRTN
 TFR X,Y
MEMC2 LDX #SEPMSG
 LBSR PSTRNG
 TFR Y,X
 LBSR OUT4H
 LBSR OUT1S
 LDA ,Y
 LBSR OUT2H
 LBSR OUT1S
 LBSR BYTE
 BVC CHANGE
 CMPA #$08
 BEQ MEMC2
 CMPA #$18
 BEQ MEMC2
 CMPA #$5E
 BEQ BACK
 CMPA #$0D
 BNE FORWRD
CHRTN RTS
*
CHANGE STA ,Y
 CMPA ,Y
 BEQ FORWRD
 LBSR OUT1S
 LDA #$3F
 LBSR OUTCH
FORWRD LEAY $01,Y
 BRA MEMC2
*
BACK LEAY -$01,Y
 BRA MEMC2
*
** "S" DISPLAY CONTENTS OF STACK
*
DISSTK LBSR PRTSP
 TFR U,Y
 LDX #STACK
 LEAX -$01,X
 BRA MDUMP1
*
MEMDUMP LBSR IN2ADR
 BVS EDPRTN
MDUMP1 PSHS Y
 CMPX ,S++
 BCC AJDUMP
EDPRTN RTS
*
* ADJUST LOWER AND UPPER ADDRESS LIMITS
* TO EVEN 16 BYTE BOUNDARIES.
* ENTER WITH LOWER ADDRESS IN XREG
*            UPPER ADDRESS ON TOP OF STACK.
*
AJDUMP TFR X,D
 ADDD #$0010
 ANDB #$F0
 PSHS B,A
 TFR Y,D
 ANDB #$F0
 TFR D,X
NXTLIN CMPX ,S
 BEQ SKPDMP
 LBSR INCHEK
 BEQ EDUMP
SKPDMP LEAS $02,S
 RTS
*
** "E" DUMP MEMORY
*
EDUMP PSHS X
 LDX #SEPMSG
 LBSR PSTRNG
 LDX ,S
 LBSR OUT4H
 LBSR OUT2S
 LDB #$10
ELOOP LDA ,X+
 LBSR OUT2H
 LBSR OUT1S
 DECB 
 BNE ELOOP
 LBSR OUT2S
 LDX ,S++
 LDB #$10
EDPASC LDA ,X+
 CMPA #$20
 BCS PERIOD
 CMPA #$7E
 BLS PRASC
PERIOD LDA #$2E
PRASC LBSR OUTCH
 DECB 
 BNE EDPASC
 BRA NXTLIN
*
** GO TO SPECIFIED ADDRESS (SET PC AND CONTINUE)
*
GO      LBSR   ALTPC1    SET UP NEW PC
        BVC    CONTIN    ADDRESS OK, GO
        RTS              NOT OK, BOMB OUT
CONTIN  TFR U,S
RTI     RTI
*
** "O"  CHANGE OUTPUT DEVICE
*
SETOUT CLRB DISABLE ALL
SETOU1 LBSR INCH GET ARGUMENT
 CMPA #'S SERIAL ?
 BNE SETOU2
 LBSR ACINIZ YES,INITIATE
 EORB #SERBIT YES, SET BIT
 BRA SETOU1

SETOU2 EQU *
 IFD DG640OPT
 CMPA #'V VIDEO ?
 BNE SETOU3
 LBSR VINIZ
 EORB #VDUBIT
 BRA SETOU1
 ENDIF DG640OPT

 IFD ADM3AOPT
 CMPA #'V VIDEO ?
 BNE SETOU3
 LBSR VINIZ
 EORB #VDUBIT
 BRA SETOU1
 ENDIF ADM3AOPT

SETOU3 EQU *
 IFD PRTOPT
 CMPA #'P PRINTER ?
 BNE SETOU4
 LBSR PINIZ
 EORB #PRTBIT
 BRA SETOU1

 ENDIF PRTOPT
SETOU4 STB OUTFLG SET UP FLAG
 RTS
*
** "I" CHANGE INPUT DEVICE
*
SETIN CLRB DISABLE ALL
SETIN1 LBSR INCH GET ARGUMENT
 CMPA #'S SERIAL ?
 BNE SETIN2
 LBSR ACINIZ YES,INITIATE
 EORB #SERBIT YES, SET BIT
 BRA SETIN1

SETIN2 EQU *
 IFD KBDOPT
 CMPA #'K Keyboard ?
 BNE SETIN3
 LBSR KBINIZ
 EORB #KBDBIT
 BRA SETIN1
 ENDIF KBDOPT

SETIN3 STB INFLG SET UP FLAG
 RTS
*
** "B" SET BREAKPOINT
*
BRKPNT LBSR IN1ADR
 BVS EXITBP
 CMPX #STACK
 BCC BPERR
 PSHS X
 LDX #$FFFF
 LBSR BPTEST
 PULS X
 BEQ BPERR
 LDA ,X
 CMPA #$3F
 BEQ BPERR
 STA ,Y+
 STX ,Y
 LDA #$3F
 STA ,X
EXITBP RTS
*
BPERR LBSR OUT1S
 LDA #$3F
 LBRA OUTCH
XBKPNT LDY #BPTBL
 LDB #$08
XBPLP LBSR RPLSWI
 DECB 
 BNE XBPLP
 RTS
*
 IFD TRAOPT
*
** TRACE from address AAAA BB bytes
*
TRACE   LBSR ALTPC1 SET UP NEW PC
        BVS TREXIT ADDRESS ERROR, EXIT
        LBSR OUT1S
        LBSR IN1ADR Fetch Byte Count
        BVS TREXIT Byte Count error, EXIT
        STX TRACNT
*
        LDX NMI Save NMI Vector
        STX NMISAV
        LDX #NMIE Set up NMI for Tracing
        STX NMI
        LBSR TRAINZ   Initialise Hardware
        BRA TRACEG    Start Trace
TREXIT  RTS
*
* CRA0 = 0 CA1 IRQ DISAB, CRA0 = 1 CA1 IRQ ENAB
* CRA1 = 1 CA1 Rising edge IRQ
* CRA2 = 0 TADATA = Data Direction, CRA2 = 1 TADATA = I/O Register
* CRA3 = 0 CA2 = 0 output, CRA3 = 1 CA2 = 1
* CRA4 = 1 ] CA2 = Set/Reset output
* CRA5 = 1 ]
* CRA6 = X CA2 Input Interrupt Flag
* CRA7 = X CA1 Interrupt Flag
*
* CRB0 = 0 CB1 IRQ DISAB, CRB0 = 1 CA1 IRQ ENAB
* CRB1 = 1 CB1 Rising edge IRQ
* CRB2 = 0 TBDATA = Data Direction, CRB2 = 1 TBDATA = I/O Register
* CRB3 = 0 CB2 = 0 output, CRB3 = 1 CB2 = 1
* CRB4 = 1 ] CB2 = Set/Reset output
* CRB5 = 1 ]
* CRB6 = X CB2 Input Interrupt Flag
* CRB7 = X CB1 Interrupt Flag
*
*
** TRACE NMI ENTRY POINT
*
NMIE    TFR S,U
        LDA #$36         Disable Interrupt, CA2 Low
        STA TACTRL
        LDA TADATA       Clear Interrupt flag by reading data port
*
        LBSR REGSTR       DUMP REGISTERS
*
        LDX 10,U         TEST IF NEXT INSTRUCTION IS A SWI
        LDA ,X
        CMPA #$3F
        BEQ TRACEX       EXIT ON SWI
*
        LDX TRACNT       CHECK IF TRACE COUNT EXPIRED
        BEQ TRACEX       YES, GO BACK TO THE MONITOR
        LEAX -1,X        DECREMENT TRACE COUNT
        STX TRACNT
*
**  TRACE GO (RESUME SINGLE STEP)
*
TRACEG  TFR U,S          SET UP PROGRAM STACK POINTER
        LDA #TRADEL      SET UP TIMER DELAY (NUMB CYCLES FOR RTI+1)
        STA TADATA
        LDA #$36         LOAD STROBE LOW
        STA TACTRL
        LDA TADATA       CLEAR INTERRUPT
        LDA #$36         RELEASE RESET
        STA TBCTRL
        LDA #$3F         RELEASE LOAD, ENABLE CA1 NMI, CA1 RISING EDGE
        STA TACTRL
        RTI              GO EXECUTE INSTRUCTION
*
TRACEX  LDX NMISAV       Restore NMI vector
        STX NMI
        LBRA NEXTCMD     Jump back to the command loop.
*
** TRACE HARDWARE INITIALISATION
*
TRAINZ  LDA #$32         SELECT DDRA, CA2 LOW, NMI DISABLED
        STA TACTRL
        LDA #$3A         SELECT DDRB, CB2 HIGH, FIRQ DISABLED
        STA TBCTRL
        LDA #$FF         PORTA = OUTPUT
        STA TADATA
        LDA #$00         PORTB = INPUT
        STA TBDATA
        LDA #$36         SELECT OUTPUT REGISTER A, CA2 LOW
        STA TACTRL
        LDA #$3E         SELECT OUTPUT REGISTER B, CB2 HIGH
        STA TBCTRL
        RTS
*
 ENDIF TRAOPT
*
** SWI ENTRY POINT
*
SWIE TFR S,U
 LDX $0A,U
 LEAX -$01,X
 BSR BPTEST
 BEQ REGPR
 STX $0A,U
 BSR RPLSWI
REGPR LBSR REGSTR
*
 IFD TRAOPT
 LDX #0
 STX TRACNT
 ENDIF TRAOPT
*
 LBRA NEXTCMD
*
* Replace SWI if Break point
*
RPLSWI LDX $01,Y
 CMPX #STACK
 BHS FFSTBL
 LDA ,X
 CMPA #$3F
 BNE FFSTBL
 LDA ,Y
 STA ,X
FFSTBL LDA #$FF
 STA ,Y+
 STA ,Y+
 STA ,Y+
LRA EQU *
DUMRTS EQU *
 RTS
*
BPTEST LDY #BPTBL
 LDB #$08
FNDBP LDA ,Y+
 CMPX ,Y++
 BEQ BPADJ
 DECB 
 BNE FNDBP
 RTS
BPADJ LEAY -$03,Y
 RTS
*
*
** "L" LOAD S1 FORMAT TAPE
*
LOAD LDA #$11
 BSR LDOUTC
 CLR ECHO
LOAD1 LBSR ECHON
LOAD2 CMPA #$53
 BNE LOAD1
 LBSR ECHON
 CMPA #$39
 BEQ LOAD21
 CMPA #$31
 BNE LOAD2
 LBSR BYTE
 PSHS A
 BVS LODERR
 LBSR IN1ADR
 BVS LODERR
 PSHS X
 LDB ,S+
 ADDB ,S+
 ADDB ,S
 DEC ,S
 DEC ,S
LOAD10 PSHS B
 LBSR BYTE
 PULS B
 BVS LODERR
 PSHS A
 ADDB ,S+
 DEC ,S
 BEQ LOAD16
 STA ,X+
 BRA LOAD10
*
LODERR CLRB
LOAD16 PULS A
 CMPB #$FF
 BEQ LOAD
 LDA #$3F
 BSR LDOUTC
LOAD21 COM ECHO
 LDA #$13
LDOUTC LBRA OUTCH
*
** "P" PUNCH S1 FORMAT TAPE
*
PUNCH CLR ,-S
 BSR IN2ADR
 PSHS Y,X
 BVS PUNEXT
 CMPX $02,S
 BCS PUNEXT
 LEAX $01,X
 STX ,S
 LDA #$12
 LBSR OUTCH
PUNCH2 LDD ,S
 SUBD $02,S
 BEQ PUNCH3
 CMPD #$0020
 BLS PUNCH4
PUNCH3 LDB #$20
PUNCH4 STB $04,S
 LDX #S1MSG
 LBSR PSTRNG
 ADDB #$03
 TFR B,A
 LBSR OUT2H
 LDX $02,S
 LBSR OUT4H
 ADDB $02,S
 ADDB $03,S
PUNCHL ADDB ,X
 LDA ,X+
 LBSR OUT2H
 DEC $04,S
 BNE PUNCHL
 COMB 
 TFR B,A
 LBSR OUT2H
 STX $02,S
 CMPX ,S
 BNE PUNCH2
PUNEXT LDA #$14
 BSR OUT1C
 LEAS $05,S
 RTS
*
** MEMORY BLOCK MOVE
*
BLKMOV BSR IN2ADR GET START AND END
 BVS BLKMV3 BAD ENTRY
 PSHS X SAVE SRC END
 LDA #'>
 BSR OUT1C
 BSR IN1ADR GET DESTINATION
 BVS BLKMV2 ERROR IN DEST
BLKMV1 LDA ,Y+ GET BYTE
 STA ,X+ STORE IT
 CMPY ,S REACH END ADDRESS
 BNE BLKMV1
BLKMV2 PULS X RESTORE STACK
BLKMV3 RTS
*
** GET TWO VALID ADDRESSES
*
IN2ADR BSR IN1ADR
 BVS NOTHEX
 TFR X,Y
 LDA #$2D
 BSR OUT1C
*
** GET ONE ADDRESS
*
IN1ADR BSR BYTE
 BVS NOTHEX
 TFR D,X
 BSR BYTE
 BVS NOTHEX
 PSHS X
 STA $01,S
 PULS X,PC
*
** READ A HEX BYTE
*
BYTE BSR INHEX
 BVS NOTHEX
 ASLA 
 ASLA 
 ASLA 
 ASLA 
 TFR A,B
 BSR INHEX
 BVS NOTHEX
 PSHS B
 ADDA ,S+
 RTS
*
** READ A SINGLE HEX DIGIT
*
INHEX LBSR ECHON
 CMPA #$30
 BCS NOTHEX
 CMPA #$39
 BHI INHEXA
 SUBA #$30
 RTS
*
INHEXA CMPA #$41
 BCS NOTHEX
 CMPA #$46
 BHI NOTHEX
 SUBA #$37
 RTS
*
NOTHEX ORCC #$02
 RTS
*
OUT2S BSR OUT1S
OUT1S LDA #$20
OUT1C LBRA OUTCH
*
** ALTER X INDEX REGISTER
*
ALTRX LBSR PRTIX
 BSR OUT1S
 BSR IN1ADR
 BVS ALTXD
 STX $04,U
ALTXD RTS
*
** ALTER A ACCUMULATOR
*
ALTRA LBSR PRTA
 BSR OUT1S
 BSR BYTE
 BVS ALTAD
 STA $01,U
ALTAD RTS
*
** ALTER DIRECT PAGE REGISTER
*
ALTRDP LBSR PRTDP
 BSR OUT1S
 BSR BYTE
 BVS ALTDPD
 STA $03,U
ALTDPD RTS
*
** ALTER PROGRAM COUNTER
*
ALTRPC BSR PRTPC
ALTPC1 BSR OUT1S
 BSR IN1ADR
 BVS ALTPCD
 STX $0A,U
ALTPCD RTS
*
** ALTER U STACK POINTER
*
ALTRU BSR PRTUP
 BSR OUT1S
 BSR IN1ADR
 BVS ALTUD
 STX $08,U
ALTUD RTS
*
** ALTER Y INDEX REGISTER
*
ALTRY BSR PRTIY
 BSR OUT1S
 LBSR IN1ADR
 BVS ALTYD
 STX $06,U
ALTYD RTS
*
** ALTER B ACCUMULATOR
*
ALTRB BSR PRTB
 BSR OUT1S
 LBSR BYTE
 BVS ALTBD
 STA $02,U
ALTBD RTS
*
** ALTER CONDITION CODES
*
ALTRCC BSR PRTCC
 BSR OUT1S
 LBSR BYTE
 BVS ALTCCD
 ORA #$80
 STA ,U
ALTCCD RTS
*
** DUMP REGISTERS
*
REGSTR LDX #SEPMSG
 LBSR PSTRNG
 BSR PRTSP
 BSR PRTIX
 BSR PRTA
 BSR PRTDP
 BSR PRTPC
 LDX #SEPMSG
 LBSR PSTRNG
 BSR PRTUP
 BSR PRTIY
 BSR PRTB
 BRA PRTCC
*
** DISPLAY CONTENTS OF STACK
*
PRTSP LDX #SPMSG
 LBSR PDATA
 TFR U,X
 BRA OUT4H
*
PRTIX LDX #IXMSG
 LBSR PDATA
 LDX $04,U
 BRA OUT4H
*
PRTA LDX #AMSG
 BSR PDATA
 LDA $01,U
 BRA OUT2H
*
PRTDP LDX #DPMSG
 BSR PDATA
 LDA $03,U
 BRA OUT2H
*
PRTPC LDX #PCMSG
 BSR PDATA
 LDX $0A,U
 BRA OUT4H
*
PRTUP LDX #UPMSG
 BSR PDATA
 LDX $08,U
 BRA OUT4H
*
PRTIY LDX #IYMSG
 BSR PDATA
 LDX $06,U
 BRA OUT4H
*
PRTB LDX #BMSG
 BSR PDATA
 LDA $02,U
 BRA OUT2H
*
PRTCC LDX #CCMSG
 BSR PDATA
 LDA ,U
 LDX #REGMSG
*
** BINARY TO ASCII CONVERSION
*
BIASCI PSHS A
 LDB #$08
OUTBA LDA ,X+
 ASL ,S
 BCS PRTBA
 LDA #$2D
PRTBA LBSR OUTCH
 LBSR OUT1S
 DECB 
 BNE OUTBA
 PULS A,PC
*
** OUTPUT A 4DIGIT HEX NUMBER
*
OUT4H PSHS X
 PULS A
 BSR OUT2H
 PULS A
*
** OUTPUT 2DIGIT HEX NUMBER
*
OUT2H PSHS A
 LSRA 
 LSRA 
 LSRA 
 LSRA 
 BSR XASCII
 PULS A
 ANDA #$0F
XASCII ADDA #$30
 CMPA #$39
 BLE OUTC
 ADDA #$07
OUTC BRA OUTCH
*
** PRINT CR, LF, STRING
*
PSTRNG BSR PCRLF
 BRA PDATA
PCRLF PSHS X
 LDX #CRLFST
 BSR PDATA
 PULS X,PC
*
PRINT BSR OUTCH
PDATA LDA ,X+
 CMPA #$04
 BNE PRINT
 RTS
*************************************
*
** INPUT CHARACTER CHECK
*
*************************************
INCHEK PSHS A,B
 LDB INFLG
 CLRA
*
 IFD SEROPT
 BITB #SERBIT
 BEQ INCHK1
 BSR ACINCHK
 BNE INCHKRT
INCHK1 EQU *
 CLRA    default to no  RX Ready
 ENDIF SEROPT
*
 IFD KBDOPT
 BITB #KBDBIT
 BEQ INCHK2
 LBSR KBINCHK
 BNE INCHKRT
INCHK2 EQU *
 CLRA  Default no RX Ready
 ENDIF KBDOPT
*
INCHKRT EQU *
 PULS A,B,PC
*************************************
*
** INPUT CHARACTER WITH NO ECHO
*
*************************************
INCH PSHS B
INCH0 LDB INFLG
*
 IFD SEROPT
 BITB #SERBIT
 BEQ  INCH1
 BSR  ACINCHK
 BEQ  INCH1
 LBSR ACINCH
 BRA  INCHRT
INCH1 EQU *
 ENDIF SEROPT
*
 IFD KBDOPT
 BITB #KBDBIT
 BEQ  INCH2
 LBSR KBINCHK
 BEQ  INCH2
 LBSR KBINCH
 BRA  INCHRT
INCH2 EQU *
 ENDIF KBDOPT
*
 BRA INCH0
INCHRT PULS B,PC
*************************************
*
** INPUT CHARACTER AND ECHO IF FLAG SET
*
*************************************
ECHON TST ECHO
 BEQ INCH
INCHE BSR INCH
*************************************
*
** OUTPUT CHARACTER IN ACCA
** FIRST DETERMINE WHICH OUTPUT ROUTINE(S) TO USE
*
*************************************
OUTCH  PSHS   B
        LDB    OUTFLG
 IFD PRTOPT
        BITB   #PRTBIT
        BEQ OUTCH2
        BSR POUTCH
OUTCH2  EQU * 
 ENDIF PRTOPT
 IFD SEROPT
        BITB   #SERBIT
        BEQ    OUTCH3
        BSR    ACOUTCH
OUTCH3 EQU *
 ENDIF SEROPT
 IFD DG640OPT
        BITB   #VDUBIT
        BEQ    OUTCH4
        LBSR   VOUTCH
OUTCH4  EQU *
 ENDIF DG640OPT
 IFD ADM3AOPT
        BITB   #VDUBIT
        BEQ    OUTCH4
        LBSR   VOUTCH
OUTCH4  EQU *
 ENDIF ADM3AOPT
        PULS   B,PC
*
 IFD SEROPT
*************************************
*
** INITIATE ACIA
*
*************************************
ACINIZ LDX CPORT
 LDA #$03
 STA ,X
 LDA #$11
 STA ,X
 TST $01,X
 LDA #$FF
 STA ECHO
 RTS
*************************************
*
** ACIA INPUT CHECK
*
*************************************
ACINCHK PSHS A
 LDA [CPORT]
 BITA #$01
 PULS A,PC
*************************************
*
** ACIA INPUT
*
*************************************
ACINCH PSHS X
 LDX CPORT
ACIN1 LDA ,X
 BITA #$01
 BEQ  ACIN1
 LDA $01,X
 PULS X,PC
*
*************************************
*
** ACIA OUTPUT CHARACTER TO CONTROL PORT
*
*************************************
ACOUTCH  PSHS B,X
 LDX CPORT
ACOUT1 LDB ,X
 BITB #$02
 BEQ ACOUT1
 STA $01,X
 PULS B,X,PC
*
 ENDIF SEROPT
*
 IFD KBDOPT
*
*************************************
*
** INITIATE KEYBOARD
*
*************************************
KBINIZ RTS
*************************************
*
** KEYBOARD INPUT CHECK
*
*************************************
KBINCHK PSHS A
 LDA KBPORT
 BITA #$01 Check RX Ready
 PULS A,PC
*
*************************************
*
** KEYBOARD INPUT
*
*************************************
KBINCH BSR KBINCHK
 BEQ KBINCH
 LDA KBPORT+1
 RTS
*
*************************************
*
** KEYBOARD OUTPUT CHARACTER
*
*************************************
KBOUTCH  PSHS B,X
 LDX #KBPORT
KBOU1 LDB ,X
 BITB #$02
 BEQ KBOU1
 STA $01,X
 PULS B,X,PC
*
 ENDIF KBDOPT
*
 IFD PRTOPT
*************************************
*
** PRINTER DRIVER ROUTINES
*
*************************************
*
** PINIZ - INITIATE PRINTER PORT
*
PINIZ PSHS B
 LDD #DIRMSK*256+$04 ACCA=DIRMSK ACCB=$04
 STD PADATA SET DDR AND SELECT DATA
*
** RESET PRINTER
 LDB #PRESET
 STAB PADATA
RESTLP INCB DELAY FOR RESET
 BNE RESTLP
 STAA PADATA ACCA=DIRMSK
*
** INITALIZE PORT B (DATA PORT)
 LDAA #$2A
 STAA PBCTRL
 LDD #$FF2E ACCA=$FF ACCB =%00101110
 STD PBDATA PBDREG   PBCTRL
*
** SELECT 66 LINES/PAGE
 LDAA #$1B
 BSR POUTCH
 LDAA #'C
 BSR POUTCH
 LDAA #66
 PULS B
*************************************
*
** OUTPUT A CHARACTER TO THE PRINTER
*
*************************************
POUTCH PSHS B
 LDAB PBDATA CLEAR INTERRUPT BIT
*
** WAIT TILL NOT BUSY
BUSYLP LDAB PADATA
 BITB #PERROR
 BEQ PEXIT
 TSTB
 BMI BUSYLP
*
** NOW OUTPUT CHARACTER
 STAA PBDATA
PEXIT PULS B,PC
*************************************
*
** PCHK TEST IFD PRINTER READY
*
*************************************
PCHK TST PBCTRL TEST STATE OF CRB7
 RTS SET ON ACKNOWLEDGE
 ENDIF PRTOPT
*
 IFD DG640OPT
***************************************************
*      TELEVIDEO-TYPE MEMORY-MAPPED EMULATOR      *
*                                                 *
* FOR HARD-WIRED MEMORY-MAPPED DISPLAYS USING THE *
* HIGH ORDER BIT OF EACH BYTE FOR  REVERSE  VIDEO *
* CURSORING  (SUCH  AS THE THOMAS INSTRUMENTATION *
* 16x64 BOARD).                                   *
***************************************************

***************************************************
*               INITIALIZE EMULATOR               *
***************************************************

VINIZ   LDX    #0
        STX    COLADX    AND ROWADX
        STX    NEWROW    AND ESCFLG
        LDX    #SCREEN   POINT TO SCREEN
        STX    CURSOR    SET PROGRAM CURSOR
        LDA    #$1B      SEND ESCAPE
        BSR    VOUTCH
        LDA    #'Y       CLEAR TO END OF SCREEN
*
** VIDEO OUTPUT ROUTINE
*
VOUTCH  PSHS   A,B,X     SAVE REGISTERS
*
** CLEAR CURSOR
        LDX    CURSOR
        LDB   0,X
        ANDB   #$7F
        STB   0,X
*
** CHECK FOR ESCAPE SEQUENCE
        TST    ESCFLG    ESCAPE ACTIVE?
        BEQ    SOROU1    BRANCH IF NOT
        BSR   ESCAPE    ELSE DO ESCAPE
        BRA    RETURN    AND RETURN
*
** CHECK FOR CONTROL CHARACTERS
SOROU1  CMPA   #$20      CONTROL CODES?
        BHS    SOROU2
        BSR    CONTRL    BRANCH IF SO
        BRA    RETURN
*
** OUTPUT TEXT CHARACTER
SOROU2  LDX    CURSOR    ELSE GET CURSOR
        STAA   0,X       DISPLAY CHARACTER
        LBSR   NEWCOL    UPDATE COLUMN
*
** DISPLAY CURSOR AND RETURN
RETURN  LDX    CURSOR    AND DISPLAY IT
        LDB   X
        ORAB   #$80      WITH REVID
        STB   X
        PULS   A,B,X,PC  RESTORE REGISTERS AND RETURN

***************************************************
*              CONTROL CODE HANDLERS              *
***************************************************

CONTRL  CMPA   #$08      CTRL H - BACKSPACE ?
        LBEQ   BACKSP
        CMPA   #$1B      ESCAPE SEQUENCE?
        LBEQ   SETESC
        CMPA   #$D       CTRL M - RETURN?
        LBEQ   CRETN
        CMPA   #$0A      CTRL J - LINE FEED
        BNE    RETESC    NONE OF THESE, RETURN

***************************************** LINE FEED

LINEFD  LDD    COLADX    GET CURRENT COLUMN AND ROW
        INCB             BUMP ROW
        CMPB   #NUMLIN   SCROLL TIME?
        LBNE   NEWCUR    POSITION CURSOR IF NOT
        LBRA   SCROLL    ELSE SCROLL IT

***************************************** LINE FEED

LINEUP  LDD    COLADX    GET CURRENT COLUMN AND ROW
        TSTB		 AT TOP OF SCREEN ?
        BEQ   RETESC    Yes, Ignore
        DECB             No, Decrement ROW
        BRA   NEWCUR    POSITION CURSOR


*********************************** BACK SPACE

BACKSP  LDA    COLADX
        BEQ    RETESC      RETURN
        DECA
        BRA   POSCOL    POSITION CURSOR

*********************************** CURSOR RIGHT

CHRIGHT LDA    COLADX
        INCA
        CMPA   #LINLEN
        BEQ   RETESC
        BRA   POSCOL

***************************************************
*                 ESCAPE HANDLERS                 *
***************************************************

ESCAPE  LDAB   ESCFLG    GET FLAG
        CMPB   #'=       SETTING CURSOR?
        BEQ    ESCCUR    BRANCH IF SO
        CMPA   #'Y       CLEAR TO END OF SCREEN?
        LBEQ   ESCCLS
        CMPA   #'T       CLEAR TO END OF LINE?
        BEQ   ESCCLL
        CMPA   #'E       INSERT LINE?
        BEQ   ESCINL
        CMPA   #'R       DELETE LINE?
        BEQ   ESCDLL
        CMPA   #'=       STARTING CURSOR SET?
        BNE    CLRESC    BRANCH IF NOT

***************************** START ESCAPE SEQUENCE

SETESC  STAA   ESCFLG    ELSE START CURSORING
        RTS              AND RETURN

CLRESC  CLR    ESCFLG    NO OTHERS SUPPORTED
RETESC  RTS              SO RETURN

********************************* SET SCREEN CURSOR

ESCCUR  TST    NEWROW    ROW SET?
        BNE    ESCCU1    BRANCH IF SO
        STAA   NEWROW    ELSE SET NEW ROW
        RTS              AND RETURN

ESCCU1  CLR    ESCFLG
        SUBA   #$20      ADJUST COLUMN ADDRESS
        CMPA   #LINLEN-1 CHECK FOR ACCEPTABLE COLUM
        BHI    RETESC    NOT OK, DO NOTHING

ESCCU2  LDAB   NEWROW
        CLR    NEWROW
        SUBB   #$20      ADJUST TO ROW ADDRESS
        CMPB   #NUMLIN-1 CHECK FOR ACCEPTABLE ROW
        BHI    RETESC    ELSE RETURN DOING NOTHING
        BRA   NEWCUR    GO SET NEW CURSOR IF SO
*
*************************** DELETE LINE FROM SCREEN

ESCDLL  BSR    CRETN     GO COL. ZERO
        LDB    ROWADX
        CMPB   #NUMLIN-1
        BEQ   SCROL3
        BRA   SCROL1    AND DELETE THIS LINE

*************************** INSERT LINE INTO SCREEN

ESCINL  BSR    CRETN    GO TO COL. ZERO
        LDAB   ROWADX
        CMPB   #NUMLIN-1
        BEQ    ESCCLL
*
** SCROLL SCREEN DOWN FROM CURSOR
*
        LDX    #SCREEN+SCNLEN-LINLEN
ESCIN0  LDAA   0,-X
        STAA   LINLEN,X
        LDA    SCNLEN,X
        STA    SCNLEN+LINLEN,X
        CPX    CURSOR
        BNE    ESCIN0

****************** CLEAR FROM CURSOR TO END OF LINE

ESCCLL  LDA    COLADX    GET CURRENT COLUMN
        LDX    CURSOR    GET CURSOR
        LDB    #$20      AND CLEAR CHAR
ESCLL1  STB    SCNLEN,X  CLEAR ATTRIBUTE
        STB    ,X+       CLEAR TEXT
        INCA
        CMPA   #LINLEN   UNTIL END OF LINE
        BNE    ESCLL1
        CLR    ESCFLG
        RTS

*********************************** CARRIAGE RETURN

CRETN   CLRA               SET COLUMN ZERO
POSCOL  LDB    ROWADX    GET CURRENT ROW

*********** GENERATE NEW CURSOR POSITION AND RETURN

NEWCUR  STD    COLADX    SAVE NEW ROW AND COLUMN
        LDA    #LINLEN   ELSE ADD A LINE
        MUL              LINLEN * ROWADX
        ADDB   COLADX
        ADCA   #0
        ADDD   #SCREEN   ADD SCREEN BASE.
        STD    CURSOR    SAVE NEW CURSOR
        TFR    D,X       GET CURSOR IN X
        RTS              AND RETURN

********************* UPDATE CURRENT COLUMN AND ROW

NEWCOL  LDD    COLADX    GET ROW AND COLUMN
        INCA             BUMP COLUMN
        CMPA   #LINLEN   ROLL?
        BNE    NEWCUR    BRANCH IF NOT
        CLRA             ELSE RESET TO ZERO
        INCB             AND BUMP ROW
        CMPB   #NUMLIN
        BNE    NEWCUR
        DECB             BOTTOM ROW
        BSR    NEWCUR

********************************* SCROLL THE SCREEN

SCROLL  LDX    #SCREEN   POINT TO SCREEN
SCROL1  LDA    SCNLEN+LINLEN,X
        STA    SCNLEN,X
        LDAA   LINLEN,X  MOVE TWO BYTES
        STAA   0,X+      UP ONE LINE
        CMPX   #SCREEN+SCNLEN-LINLEN
        BNE    SCROL1    LOOP UNTIL DONE
        BRA SCROL3

**************** CLEAR FROM CURSOR TO END OF SCREEN

ESCCLS  LDX    CURSOR    GET CURSOR
SCROL3  LDAA   #$20      GET A SPACE
SCROL2  STA    SCNLEN,X  CLEAR ATTRIBUTES
        STA    ,X+       AND TEXT
        CMPX   #SCREEN+SCNLEN
        BNE    SCROL2    UNTIL DONE
        CLR    ESCFLG
     RTS
 ENDIF DG640OPT
*
 IFD ADM3AOPT
***************************************************
*      ADM3A REGISTER-MAPPED EMULATOR             *
*                                                 *
*      80 x 25 Characters
*
***************************************************

***************************************************
*               INITIALIZE EMULATOR               *
***************************************************

VINIZ   LDX    #VDU
        LDD    #0
        STD    COLADX    AND ROWADX
        STA    VDUCOL,X
        STB    VDUROW,X 
        STB    VDUOFF,X
        STD    NEWROW    AND ESCFLG
        LDB    #$02
        STB    VDUATT,X
        CLR    ESCFLG
        LDA    #$1B      SEND ESCAPE
        BSR    VOUTCH
        LDA    #'Y       CLEAR TO END OF SCREEN
*
** VIDEO OUTPUT ROUTINE
*
VOUTCH  PSHS   A,B,X     SAVE REGISTERS
        LDX    #VDU      POINT TO VDU REGISTERS
*
** CHECK FOR ESCAPE SEQUENCE
        TST    ESCFLG    ESCAPE ACTIVE?
        BEQ    SOROU1    BRANCH IF NOT
        BSR    ESCAPE    ELSE DO ESCAPE
        BRA    RETURN    AND RETURN
*
** CHECK FOR CONTROL CHARACTERS
SOROU1  CMPA   #$20      CONTROL CODES?
        BHS    SOROU2
        BSR    CONTRL    BRANCH IF SO
        BRA    RETURN
*
** OUTPUT TEXT CHARACTER
SOROU2  STAA   VDUCHR,X  DISPLAY CHARACTER
        LBSR   NEWCOL    UPDATE COLUMN
*
** DISPLAY CURSOR AND RETURN
RETURN  PULS   A,B,X,PC  RESTORE REGISTERS AND RETURN

***************************************************
*              CONTROL CODE HANDLERS              *
***************************************************

CONTRL  CMPA   #$08      CTRL H - BACKSPACE ?
        LBEQ   BACKSP
        CMPA   #$1B      ESCAPE SEQUENCE?
        LBEQ   SETESC
        CMPA   #$1A      CTRL Z - Clear Screen
        LBEQ   CLRSCR
        CMPA   #$16      CTRL ^ - Home
        LBEQ   HOME
        CMPA   #$D       CTRL M - RETURN?
        LBEQ   CRETN
        CMPA   #$0C      CTRL L - CHAR RIGHT
        LBEQ   CHRIGHT
        CMPA   #$0B      CTRL K - MOVE UP ONE LINE
        LBEQ   LINEUP
        CMPA   #$0A      CTRL J - LINE FEED
        BNE    RETESC    NONE OF THESE, RETURN

***************************************** LINE FEED

LINEFD  LDD    COLADX    GET CURRENT COLUMN AND ROW
        INCB             BUMP ROW
        CMPB   #NUMLIN   SCROLL TIME?
        LBNE   NEWCUR    POSITION CURSOR IF NOT
        LBRA   SCROLL    ELSE SCROLL IT

***************************************** LINE FEED

LINEUP  LDD    COLADX    GET CURRENT COLUMN AND ROW
        TSTB		 AT TOP OF SCREEN ?
        LBEQ   RETESC    Yes, Ignore
        DECB             No, Decrement ROW
        LBRA   NEWCUR    POSITION CURSOR


*********************************** BACK SPACE

BACKSP  LDA    COLADX
        BEQ    RETESC      RETURN
        DECA
        LBRA   POSCOL    POSITION CURSOR

*********************************** CURSOR RIGHT

CHRIGHT LDA    COLADX
        INCA
        CMPA   #LINLEN
        LBEQ   RETESC
        LBRA   POSCOL

*********************************** CURSOR RIGHT

HOME    LDD    #0        HOME - POSITION TOP OF SCREEN
        LBRA    NEWCUR

***************************************************
*                 ESCAPE HANDLERS                 *
***************************************************

ESCAPE  LDAB   ESCFLG    GET FLAG
        CMPB   #'=       SETTING CURSOR?
        BEQ    ESCCUR    BRANCH IF SO
        CMPA   #'Y       CLEAR TO END OF SCREEN?
        LBEQ   ESCCLS
        CMPA   #'T       CLEAR TO END OF LINE?
        BEQ   ESCCLL
        CMPA   #'=       STARTING CURSOR SET?
        BNE    CLRESC    BRANCH IF NOT

***************************** START ESCAPE SEQUENCE

SETESC  STAA   ESCFLG    ELSE START CURSORING
        RTS              AND RETURN

CLRESC  CLR    ESCFLG    NO OTHERS SUPPORTED
RETESC  RTS              SO RETURN

********************************* SET SCREEN CURSOR

ESCCUR  TST    NEWROW    ROW SET?
        BNE    ESCCU1    BRANCH IF SO
        STAA   NEWROW    ELSE SET NEW ROW
        RTS              AND RETURN

ESCCU1  CLR    ESCFLG
        SUBA   #$20      ADJUST COLUMN ADDRESS
        CMPA   #LINLEN-1 CHECK FOR ACCEPTABLE COLUM
        BHI    RETESC    NOT OK, DO NOTHING

ESCCU2  LDAB   NEWROW
        CLR    NEWROW
        SUBB   #$20      ADJUST TO ROW ADDRESS
        CMPB   #NUMLIN-1 CHECK FOR ACCEPTABLE ROW
        BHI    RETESC    ELSE RETURN DOING NOTHING
        BRA    NEWCUR    GO SET NEW CURSOR IF SO

****************** CLEAR FROM CURSOR TO END OF LINE
CLRSCR  LDD    #0        CLEAR FROM TOP OF SCREEN
        BSR    NEWCUR
ESCCLL  LDA    COLADX
        LDB    #$20      AND CLEAR CHAR
ESCCL1  STB    VDUCHR,X  DISPLAY TEXT
        INCA
	STA    VDUCOL,X
        CMPA   #LINLEN   UNTIL END OF LINE
        BNE    ESCCL1
        CLR    ESCFLG
        RTS

*********************************** CARRIAGE RETURN

CRETN   CLRA               SET COLUMN ZERO
POSCOL  LDB    ROWADX    GET CURRENT ROW

*********** GENERATE NEW CURSOR POSITION AND RETURN

NEWCUR  STD    COLADX    SAVE NEW ROW AND COLUMN
	STA    VDUCOL,X  SET NEW COLUMN
        STB    VDUROW,X  SET NEW ROW
        RTS              AND RETURN

********************* UPDATE CURRENT COLUMN AND ROW

NEWCOL  LDD    COLADX    GET ROW AND COLUMN
        INCA             BUMP COLUMN
        CMPA   #LINLEN   ROLL?
        BNE    NEWCUR    BRANCH IF NOT
        CLRA             ELSE RESET TO ZERO
        INCB             AND BUMP ROW
        CMPB   #NUMLIN
        BNE    NEWCUR
        DECB             BOTTOM ROW
        BSR    NEWCUR

********************************* SCROLL THE SCREEN

SCROLL  LDB    VDUOFF,X
        INCB
        CMPB   #NUMLIN
        BLO    SCROL1
        CLRB
SCROL1  STB    VDUOFF,X

**************** CLEAR FROM CURSOR TO END OF SCREEN

ESCCLS  LDB    COLADX    GET CURSOR
        LDA    #$20      GET A SPACE
ESCCLS1	STB    COLADX
        STB    VDUCOL,X
        STA    VDUCHR,X
        INCB
        CMPB   #LINLEN
        BNE    ESCCLS1
*
        LDB    ROWADX
        INCB
        CMPB   #NUMLIN
        BEQ    ESCCLS2
        STB    ROWADX
        STB    VDUROW,X
        CLRB
        BRA    ESCCLS1
*
ESCCLS2 CLRB
        STB    COLADX
        STB    VDUCOL,X
        STB    ESCFLG
        RTS
 ENDIF VDUOPT
 IFD FDCOPT
*
** "D" MINI DISK BOOT
*
MINBOOT TST CMDREG
 CLR DRVREG
 LDX #$0000
LOOP LEAX $01,X
 CMPX #$0000
 BNE LOOP
 LDA #$0F
 STA CMDREG
 BSR DELAY
LOOP1 LDB CMDREG
 BITB #$01
 BNE LOOP1
 LDA #$01
 STA SECREG
 BSR DELAY
 LDA #$8C
 STA CMDREG
 BSR DELAY
 LDX #$C000
 BRA LOOP3
LOOP2 BITB #$02
 BEQ LOOP3
 LDA DATREG
 STA ,X+
LOOP3 LDB CMDREG
 BITB #$01
 BNE LOOP2
 BITB #$2C
*
* Temp Remove jump
* Manually jump to $C000
* if boot strap loaded correctly
*
* BEQ LOOP4
 RTS
*
LOOP4 LDX #$C000
 STX $0A,U
 TFR U,S
 RTI 
*
DELAY LDB #$04
LOOP5 DECB
 BNE LOOP5
 RTS
 ENDIF FDCOPT
*
 IFD VIDOPT
 IFD KBDOPT
 IFD SEROPT
*******************************************
*
* Terminal Mode
*
*******************************************
TERM LBSR KBINCHK
 BNE TERM01
 LBSR ACINCHK
 BEQ TERM
*
* acia input
*
 LBSR ACINCH
 LBSR VOUTCH
 BRA TERM
*
* keyboard input No local Echo
*
TERM01 LBSR KBINCH
 LBSR ACOUTCH
 BRA TERM
 ENDIF SEROPT
 ENDIF KBDOPT
 ENDIF VIDOPT
*
** COMMAND JUMP TABLE
*
JMPTAB FCB $01
 FDB ALTRA
 FCB $02
 FDB ALTRB
 FCB $03
 FDB ALTRCC
 FCB $04
 FDB ALTRDP
 FCB $10
 FDB ALTRPC
 FCB $15
 FDB ALTRU
 FCB $18
 FDB ALTRX
 FCB $19
 FDB ALTRY
*
 IFD VIDOPT
 IFD KBDOPT
 IFD SEROPT
 FCC "A"
 FDB TERM
 ENDIF SEROPT
 ENDIF KBDOPT
 ENDIF VIDOPT
 FCC "B"
 FDB BRKPNT
 IFD FDCOPT
 FCC "D"
 FDB MINBOOT
 ENDIF FDCOPT
 FCC "E"
 FDB MEMDUMP
 FCC "G"
 FDB GO
 FCC "I"
 FDB SETIN
 FCC "L"
 FDB LOAD
 FCC "M"
 FDB MEMCHG
 FCC "O"
 FDB SETOUT
 FCC "P"
 FDB PUNCH
 FCC "R"
 FDB REGSTR
 FCC "S"
 FDB DISSTK
*
 IFD TRAOPT
 FCC "T"
 FDB TRACE
 ENDIF TRAOPT
*
 IFD CLKOPT
 FCC "T"
 FDB TIMSET
 ENDIF CLKOPT
*
 FCC "X"
 FDB XBKPNT
 FCC "Z"
 FDB BLKMOV
JMPEND EQU *
*
RAMVEC FDB RTI
 FDB RTI
 FDB RTI
 FDB RTI
 FDB RTI
 FDB SWIE
 FDB START
 FDB $FFFF
 FDB $FFFF
*
** CHARATER STRINGS
*
TTLMSG FCB $00
 FCB $00
 FCB $00
 FCB $0D
 FCB $0A
 FCB $00
 FCB $00
 FCB $00
 FCC "TraceBug V1.1"
 FCB $04
*
CRLFST FCB $0D
 FCB $0A
 FCB $00
 FCB $00
 FCB $00
 FCB $04
*
PMTMSG FCC ">"
 FCB $04
QRYMSG FCC "WHAT?"
 FCB $04
SEPMSG FCC " - "
 FCB $04
*
SPMSG FCC "  SP="
 FCB $04
PCMSG FCC "  PC="
 FCB $04
UPMSG FCC "  UP="
 FCB $04
IYMSG FCC "  IY="
 FCB $04
IXMSG FCC "  IX="
 FCB $04
DPMSG FCC "  DP="
 FCB $04
AMSG FCC "  A="
 FCB $04
BMSG FCC "  B="
 FCB $04
CCMSG FCC "  CC: "
 FCB $04
*
REGMSG FCC "EFHINZVC"
S1MSG FCC "S1"
 FCB $04
 IFD CLKOPT
*
* CLOCK INTER FACE UTILITY
*
* TIME <Hours> <Minuits> <Seconds>
* If no argument is specified, the current time
* will be displayed.
*
* READ A REGISTER FROM THE COUNTER.
* The X Index rgister points to the register
* to be read. The Status Register is checked
* before and after the register is read before
* returning a value in accumulator A
*
RDCLK  TST CLKSTA
       BNE RDCLK
RDCLK1 LDA 0,X
       TST CLKSTA
       BNE RDCLK1
       RTS
*
* MAIN PROGRAM:
*
TIMSET LDX #COUNTR POINT TO TIMER
      LBSR BYTE READ HOURS
      BVS  SHOWTM NO ARG, DISP TIME
      STA HOUR,X
      LBSR OUT1S
      LBSR BYTE READ MINUITES
      BVS  SHOWTM
      STA MINUIT,X
      LBSR OUT1S
      LBSR BYTE SECONDS.
      BVS SHOWTM
      STA SECOND,X
*
* DISPLAY CURRENT TIME
*
SHOWTM LBSR PCRLF
       LDX #COUNTR+HOUR
       LDB #3
SHOWLP BSR RDCLK
       LBSR OUT2H
       LDA #':
       LBSR OUTCH
       LEAX -1,X
       DECB
       BNE SHOWLP
       RTS
*
* INITIATE CLOCK.
* MASK INTERRUPTS.
*
CLKINZ CLR CINTCR  MASK ALL INTERRUPTS
       TST CINTSR  CLEAR ANY INTERRUPTS
       RTS
 ENDIF CLKOPT
*
** INTERRUPT JUMP TABLE
*
RESVV JMP [STACK]
SWI2V JMP [SWI2]
FIRQV JMP [FIRQ]
IRQV JMP [IRQ]
SWIV JMP [SWI]
NMIV JMP [NMI]
*
** SPECIAL CALL TO MONITOR
*
SWI3E TFR S,U
 LDX $0A,U
 LDB ,X+
 STX $0A,U
 CLRA
 ASLB 
 ROLA 
 LDX SVCVO
 CMPX #$FFFF
 BEQ SWI3Z
 LEAX D,X
 CMPX SVCVL
 BHI SWI3Z
 PSHS X
 LDD ,U
 LDX $04,U
 JMP [,S++]
SWI3Z PULU X,DP,B,A,CC
 LDU $02,U
 JMP [SWI3]
*
 ORG ROM+ROMSIZE-16
*
** 6809 INTERRUPT VECTORS
*
 FDB RESVV RESERVED
 FDB SWI3E SWI3
 FDB SWI2V SWI2
 FDB FIRQV FIRQ
 FDB IRQV IRQ
 FDB SWIV SWI
 FDB NMIV NMI
 FDB START RST
 END START

